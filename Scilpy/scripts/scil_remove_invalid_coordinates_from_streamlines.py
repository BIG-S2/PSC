#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Removes points containing invalid coordinates from the streamlines.

IMPORTANT: this script should only be used if absolutely necessary. It's better
to fix the tools than to play with the points as this script does.

A point is invalid if it has at least one negative coordinate or if it's
outside of the anatomy volume.

Note that, by default, this script will remove every point which has at least
one negative coordinate. However, if streamlines were generated using a tool
which follows the Nifti standard, it is possible that some coordinates have
values between -0.5 and 0.0, when bringing the reference frame back to the
origin.

If you know that the generation tool follows the Nifti standard, use --gnc. If
you know that the tool that will process those streamlines also correctly
considers the Nifti standard, you should use the --fnc flag.
"""

from __future__ import division

import argparse

import nibabel as nb
import numpy as np

import tractconverter as tc
from tractconverter.formats.header import Header

from scilpy.io.utils import (
    add_overwrite_arg, assert_inputs_exist, assert_outputs_exists,
    check_tracts_same_format, check_tracts_support)


def _build_arg_parser():
    p = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawTextHelpFormatter)
    p.add_argument(
        'tracts',  metavar='TRACTS', 
        help='path of the tracts file, in a format supported by the '
             'TractConverter.')
    p.add_argument(
        'ref_anat',  metavar='REF_ANAT', 
        help='path of the nifti file containing the reference anatomy.')
    p.add_argument('out', metavar='OUTPUT_FILE',
                   help='path of the output tracts file.')

    add_overwrite_arg(p)

    g = p.add_mutually_exclusive_group(required=True)
    g.add_argument(
        '--gnc', action='store_true', dest='nifti_compliant_gen',
        help='Generated by Nifti Compliant tool\nThe streamlines were '
             'generated using a tool that follows\nthe Nifti standard with '
             'regards to the reference frame definition.\nIf streamlines were '
             'generated using Mrtrix or a version of Scilpy dating\nfrom '
             'later than 2014-07-21 (commit 45bc133), use this.')
    g.add_argument(
        '--gnnc', action='store_true', dest='non_nifti_compliant_gen',
        help='Generated by a Non Nifti Compliant tool\nThe streamlines were '
             'generated using a tool that DOES NOT follow\nthe Nifti standard '
             'with regards to the reference frame definition.\nIfstreamlines '
             'were generated using a tool not in the --gnc list, use this.')

    g1 = p.add_mutually_exclusive_group(required=True)
    g1.add_argument(
        '--fnc', action='store_true', dest='for_nifti_compliant',
        help='For Nifti Compliant tools.\nSet this if the streamline file '
             'will be passed to a tool that follows\nthe Nifti standard '
             'reference frame definition.\nDipy\'s tracking.utils tools and '
             'the Fibernav follow this standard.')
    g1.add_argument(
        '--nfnc', action='store_true', dest='not_for_nifti_compliant',
        help='Not For Nifti Compliant tools.\nSet this if the streamline file '
             'will be passed to a tool\nthat DOES NOT follow the Nifti '
             'standard reference frame definition.')
    return p


def filter_points(tract_filename, ref_anat, out_filename, nifti_compliant_gen,
                  nifti_compliant_dest):
    # When generating streamlines, some tools can generate negative coordinates
    # which can still be valid. For example, if you strictly follow the
    # Nifti standard, points in the first, left-most, bottom-most voxel
    # will have coordinates in [-0.5, 0.5] when related to an anatomy starting
    # at the origin. This is considered to be the "Nifti_compliant_gen" flag.
    # In case those streamlines will be used with a Nifti compliant tool,
    # we need to shift by half a voxel to keep those valid
    # coordinates when filtering.
    # This is mandatory because Nifti compliant tools correctly keep the
    # negative coordinates. Then, if we don't shift
    # the points before filtering, we could lose those valid negative points.

    ref_img = nb.load(ref_anat)
    voxel_dim = ref_img.get_header()['pixdim'][1:4]
    anat_size = ref_img.get_shape()

    shift = 0.0
    if nifti_compliant_gen:
        shift = 0.5

    out_shift = 0.0
    if nifti_compliant_dest:
        out_shift = 0.5

    tracts_format = tc.detect_format(tract_filename)
    tracts_file = tracts_format(tract_filename, anatFile=ref_anat)

    # Since we enforce a transformation to the same filetype,
    # we know the output file will also be TCK
    if isinstance(tracts_file, tc.formats.tck.TCK):
        filtered_streamlines = []
        tracts = [(s / voxel_dim) + shift for s in tracts_file]

        for sl in tracts:
            new_sl = sl[np.all((sl >= 0) & (sl < anat_size), axis=1)]
            if len(new_sl) > 1:
                filtered_streamlines.append(new_sl)

        filtered_streamlines = [(s - out_shift) * voxel_dim
                                for s in filtered_streamlines]

        out_hdr = tracts_file.hdr
        out_hdr[Header.NB_FIBERS] = len(filtered_streamlines)
        out_format = tc.detect_format(out_filename)
        out_tracts = out_format.create(
            out_filename, out_hdr, anatFile=ref_anat)
        out_tracts += filtered_streamlines
        out_tracts.close()
    elif isinstance(tracts_file, tc.formats.trk.TRK):
        # Use nb.trackvis to read directly in correct space
        # TODO this should be made more robust, using
        # all fields in header.
        # Currently, load in voxel,
        try:
            streamlines, hdr = nb.trackvis.read(
                tract_filename, as_generator=True, points_space='voxel')
        except nb.trackvis.HeaderError as er:
            raise ValueError(
                '\n------ ERROR ------\n\n'
                'TrackVis header is malformed or incomplete.\n'
                'Please make sure all fields are correctly set.\n\n'
                'The error message reported by Nibabel was:\n'.format(er))

        tracts = []
        colors = []
        for idx, (sl, color, prop) in enumerate(streamlines):
            shift_sl = sl + shift
            new_sl = shift_sl[np.all((shift_sl >= 0) & (shift_sl < anat_size),
                                     axis=1)]
            if len(new_sl) > 1:
                tracts.append(new_sl)
                colors.append(color)

        out_strls = []
        for sl, color in zip(tracts, colors):
            out_strls.append((sl - out_shift, color, None))

        nb.trackvis.write(out_filename, out_strls, hdr, points_space='voxel')


def main():
    parser = _build_arg_parser()
    args = parser.parse_args()

    assert_inputs_exist(parser, [args.tracts, args.ref_anat])
    assert_outputs_exists(parser, args, [args.out])
    check_tracts_support(parser, args.tracts, False)
    check_tracts_same_format(parser, args.tracts, args.out)
    
    # Deactivated for now.
    # Tested implicitely with the 2 previous tracts checks.
    # if not tc.is_supported(args.out):
    #     parser.error('Format of "{0}" not supported.'.format(args.out))

    filter_points(args.tracts, args.ref_anat, args.out,
                  args.nifti_compliant_gen, args.for_nifti_compliant)


if __name__ == "__main__":
    main()
